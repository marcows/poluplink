#include <string.h>
#include "poluplink.h"

/*
 * Returns the data chunk size of the wave file.
 */
static uint32_t poluplink_calc_datachunk_size(size_t framecnt)
{
	// 441 samples/bit * 11 bits/frame * <framecnt> frames
	return framecnt * 11 * 441;
}

/*
 * Write the wave header to the wave file.
 *
 * Returns 0 on success, 1 on failure.
 */
static int poluplink_write_wav_header(FILE *wavout, uint32_t datasize)
{
	// Only this format is supported, so it is hardcoded:
	// RIFF (little-endian) data, WAVE audio, Microsoft PCM, 8 bit, mono 44100 Hz
	static uint8_t buf[44] = {
		'R', 'I', 'F', 'F', 0x00, 0x00, 0x00, 0x00, // <n> bytes remaining in RIFF chunk
		'W', 'A', 'V', 'E',
		'f', 'm', 't', ' ', 0x10, 0x00, 0x00, 0x00, // 16 bytes remaining in fmt chunk
		0x01, 0x00, // Microsoft PCM
		0x01, 0x00, // 1 channel
		0x44, 0xAC, 0x00, 0x00, // sample rate 44100 Hz
		0x44, 0xAC, 0x00, 0x00, // 44100 bytes/second
		0x01, 0x00, // 1 byte block align (frame size)
		0x08, 0x00, // 8 bits/sample
		'd', 'a', 't', 'a', 0x00, 0x00, 0x00, 0x00 // <n> bytes remaining in data chunk
	};
	uint32_t riffsize;

	// set size informations
	riffsize = datasize + 44 - 8;
	buf[4] = 0xFF & riffsize;
	buf[5] = 0xFF & (riffsize >> 8);
	buf[6] = 0xFF & (riffsize >> 16);
	buf[7] = 0xFF & (riffsize >> 24);
	buf[40] = 0xFF & datasize;
	buf[41] = 0xFF & (datasize >> 8);
	buf[42] = 0xFF & (datasize >> 16);
	buf[43] = 0xFF & (datasize >> 24);

	if (fwrite(buf, 1, 44, wavout) != 44)
		return 1;

	return 0;
}

/*
 * Write a serial bit to the wave file.
 *
 * It consists of 441 sound samples.
 *
 * Returns 0 on success, 1 on failure.
 */
static int poluplink_write_serial_bit(FILE *wavout, int logic)
{
	// use the same values as those generated by Polar UpLink Tool to be 100% compatible
	static const uint8_t sampledata[] = {
		0x00, 0x59, 0x7F, 0x5E, 0x08, 0xAE, 0x81, 0x9C, 0xF0,
		0x4C, 0x7E, 0x68, 0x18, 0xBB, 0x84, 0x93, 0xE0, 0x3E,
		0x7A, 0x71, 0x28, 0xC9, 0x88, 0x8B, 0xD0, 0x30, 0x75,
		0x78, 0x37, 0xD8, 0x8F, 0x86, 0xC2, 0x20, 0x6D, 0x7C,
		0x45, 0xE8, 0x98, 0x82, 0xB4, 0x10, 0x64, 0x7F, 0x52,
		0xF8, 0xA2, 0x81, 0xA7
	};
	uint8_t buf[441];

	// unipolar RZ code:
	// first half of samples for one bit is high level (sound) or low level
	// (silence), second half is always low level (silence)
	if (logic) {
		// 220 samples sound
		memcpy(buf + 0 * 49, sampledata, 49);
		memcpy(buf + 1 * 49, sampledata, 49);
		memcpy(buf + 2 * 49, sampledata, 49);
		memcpy(buf + 3 * 49, sampledata, 49);
		memcpy(buf + 4 * 49, sampledata, 24);
		// 221 samples silence
		memset(buf + 220, 0x80, 221);
	} else {
		// 441 samples silence
		memset(buf, 0x80, 441);
	}

	if (fwrite(buf, 1, 441, wavout) != 441)
		return 1;

	return 0;
}

/*
 * Write a serial frame to the wave file.
 *
 * It consists of 11 serial bits: 1 start, 8 payload (raw data byte), 2 stop.
 *
 * Returns 0 on success, 1 on failure.
 */
static int poluplink_write_serial_frame(FILE *wavout, uint8_t rawbyte)
{
	int i;

	// 1 start bit
	if (poluplink_write_serial_bit(wavout, 1))
		return 1;

	// 8 bits payload, LSB first
	for (i = 0; i < 8; i++) {
		if (poluplink_write_serial_bit(wavout, rawbyte & (1 << i)))
			return 1;
	}

	// 2 stop bits
	if (poluplink_write_serial_bit(wavout, 0))
		return 1;
	if (poluplink_write_serial_bit(wavout, 0))
		return 1;

	return 0;
}

/*
 * Write a wave file from the raw data bytes.
 *
 * It consists of the wave file header and <cnt> serial frames.
 *
 * Returns the number of raw bytes successfully written.
 */
size_t poluplink_export_wav(FILE *wavout, const uint8_t *rawbytes, size_t cnt)
{
	size_t i = 0;

	if (poluplink_write_wav_header(wavout, poluplink_calc_datachunk_size(cnt)))
		return i;

	for (i = 0; i < cnt; i++) {
		if (poluplink_write_serial_frame(wavout, *rawbytes))
			return i;
		rawbytes++;
	}

	return i;
}
